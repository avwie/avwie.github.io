---
slug: "/creating-multiplatform-crdts"
date: "2022-06-13"
title: "Creating multiplatform Conflict Free Replicated Data Types in Kotlin Multiplatform"
hero: "../images/20220530_mvi_compose/hero.png"
---

Sometime ago I was tinkering with some application that required state to be synchronized across different 'nodes'. 
In a previous job we already used something similar and I knew it was based on the idea of Conflict-Free Replicated
Data Types, however now I felt it was time to dive a little bit more into it and see if I can make something that would
work in a Kotlin Multiplatform environment.

## Why should I care about Conflict Free Replicated Data Types?

Imagine you have an application that has some state that the user is allowed to modify, like almost all applications.
If this application has multiple users working concurrently, we need to have _some_ way to synchronize the state between
the users. This isn't a new problem, so there are already a solutions to it. One that comes to mind is the good old 
transactional updates in a database. Make sure there is a central database and that every user can write to it in a way
that guarantees that consistency of the data-model is maintained. If one transaction is in progress while another one is
initiated by another user that changes something which is also in scope of the running transaction, then the second transaction
is rejected. Probably this will result in some sort of error to the user. Another solution might be to lock writes to the database for 1 user at a time.
Any other write will result in some error.

You can see already that we need some type of centralized database here and some form of centralized control.

So what happens if we have an application with a lot of users, like a game, with a lot of state updates? Do we need to lock
somewhere everytime? Wouldn't it be better if every user can be in control of its own state and we have a way to resolve
conflicts between those states?

## What are Conflict-Free Replicated Data Types

Well, to quote Wikipedia:

> A conflict-free replicated data type (CRDT) is a data structure which can be replicated across multiple computers in
> a network, where the replicas can be updated independently and concurrently without coordination between the replicas,
> and where it is always mathematically possible to resolve inconsistencies that might come up.

Okay, let's unpack that a bit shall we?

> A conflict-free replicated data type (CRDT) is a data structure which can be replicated across multiple computers in
> a network....

This makes sense and is pretty straight forward. We want to have some data structure to be replicated.

> ...where the replicas can be updated independently and concurrently...

So, every replica should be able to update to the latest version of the state by itself, and not by some external system.
Secondly, it should be possible for all replicas to do this at the same time, or at least without any temporal/causal relationship
between the replicas.

> ...without coordination between the replicas,...

This is a big one. There shouldn't be any supervisory system managing this. So no replica-servers, or command-and-control servers, etc.

> ...and where it is always mathematically possible to resolve inconsistencies that might come up.

This one is a bit formal I'd say. But what this means, in my opinion, is that we should have a clear set of functions that
describe how differences between multiple replicas are resolved.

There are two main branches in the CRDT-world on how to solve the conflicts:

- Operation based CRDTs
- State based CRDTs

### Operation based CRDTs

Operation based CRDTs, or commutative replicated data types (CmRDTs), update their state by specifying a very strict set
of operations which updated that state. However the big _requirement_ for these operations is that they are _commutative_,
which means that the order of applying those operations should not matter in the end result. 

So, to give a _very very very simple_ example:

```kotlin
fun incr(input: Int, amount: Int): Int = input + amount

val initialState = 0
val finalStateA = incr(incr(incr(initialState, -10), 5), -3)
val finalStateB = incr(incr(incr(initialState, 5), -3), 10)
```

As you can see it doesn't matter what order we use of the `incr(...)` functions, because the answer will always be: -8.

So in order to implement CmRDTs we need to the following:
- define all the applicable operations that can happen on the state
- make sure they are all commutative
- implement some sort of messaging protocol for the different CRDT's to communicate over, making sure no messages are dropped

The last point is pretty critical. If we miss one operation it means that the states are out of sync. So it is critical
that the communication protocol is robust.

Another drawback might be that it is very difficult to model the state using commutative operations. In some cases, 
like the example above, it might be trivial, but in some others it might require a PhD in computer science.

### State based CRDTs

State based CRDTs, or convergent replicated data types (CvRDTs), synchronize their state by having a dedicated function
that handles the converging, or merging, of two states to a single one. This merging function will contain all the logic
of the conflicts that might arise. When such a function exists it is only required that the different state holders all 
communicate their state to each other and merge the incoming state. Eventually this will lead to a consistent for all 
parties involved. Also here, the operation is commutative. It doesn't matter in which order you merge the states.

A very simple example might be:
```kotlin
val totalNumberOfClicksA = 10
val totalNumberOfClicksB = 35

fun merge(a: Int, b: Int) = max(a, b)

val mergedTotalNumberOfClicks = merge(totalNumberOfClicksA, totalNumberOfClicksB) // -> 35
```
This merge operation merges based on the highest value. But there are a different ways in handling the merges.

The downside here of course is that the full states need to be communicated to everyone.The upside of this method is
that it might be a bit easier to implement.

## Building convergent data types from the ground up

What we are going to do is create a few convergent data types from the ground up and see how we can compose them
to create more sophisticated types.

It all starts with defining an interface that all the CvRDT's need to adhere to:

```kotlin
interface Mergeable<T> where T : Mergeable<T> {
    fun merge(incoming: T): T
}
```

This interface only ensures us that a `Mergeable` value can merge with another one and returns a value of the same type
that is also `Mergeable`.

### A simple Last-Write-Wins type

In the above example we used a maximum value as the dominant value, but it is a bit of a weird example. You can imagine
that it makes more sense to have the _latest_ value to be dominant. User A writes a certain value, but User B writes 
another value at a later time.

Since we are working in Kotlin Multiplatform common code we need some date-time library that supports common code.
Luckily we can use [kotlinx-datetime](https://github.com/Kotlin/kotlinx-datetime). And we can write our implementation
like follows:

```kotlin
class MergeableValue<T>(
    val value: T,
    private val timestamp: Instant
) : Mergeable<MergeableValue<T>> {

    override fun merge(other: MergeableValue<T>): MergeableValue<T> = when {
        timestamp < other.timestamp -> other
        timestamp >= other.timestamp -> this
        else -> this
    }
}

// and some helper function
fun <T> mergeableValueOf(value: T) = MergeableValue(value, Clock.System.now())
```

As you can see we have a very simple solution here for merging. However, there is a very very sneaky bug in here, because
it isn't commutative. And we can demonstrate it via a test:

```kotlin
@Test
fun equalTimestamps() {
    val timestamp = Clock.System.now()
    val a = MergeableValue(1, timestamp)
    val b = MergeableValue(2, timestamp)

    val c1 = a.merge(b)
    val c2 = b.merge(a)
    assertEquals(c1, c2) // <- this one fails!
}
```

Somehow, `c1 != c2` even though the merge should be commutative. But looking closely to our implementation we see that
`timestamp >= other.timestamp -> this` returns `this` when the timestamps are equal. But when doing the different merges
the `this` is also different. So we need actually a different way to break the ties. For now I used the following:

```kotlin
override fun merge(other: MergeableValue<T>): MergeableValue<T> = when {
    timestamp < other.timestamp -> other
    timestamp > other.timestamp -> this

    // breaking ties based on hash
    hashCode() <  other.hashCode() -> other
    else -> this
}
```

And now it passes. Now we have a new tie when the hashcodes are equal _and_ the timestamps are equal. But at that moment
I just assume the values are equal as well. And... this is a hobby project, so I'll leave the exercise to the reader ;-).

Speaking of equality, what should happen if we do `mergeableValueOf(1) == mergeableValueOf(1)`? If the timestamps are different,
are they still equal? I decided that they should, so I wrote a test:

```kotlin
@Test
fun equalsTest() {
    val a = mergeableValueOf(1)
    sleep(1)
    val b = mergeableValueOf(1)
    assertEquals(a, b)

    val c = mergeableValueOf(2)
    assertNotEquals(a, c)
}
```

This one fails as well, and that is because we still needed to implement `equals` and `hashCode`:
```kotlin
class MergeableValue<T>(...) {
    ...
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || this::class != other::class) return false

        other as MergeableValue<*>
        if (value != other.value) return false
        return true
    }

    override fun hashCode(): Int {
        return value.hashCode()
    }
}
```
And now it passes!

As a final test we add some randomized fuzzing test, where we shuffle a list of mergeables, and merge them all together.
It shouldn't matter in what order they are merged:
```kotlin
@Test
fun fuzz() {
    val values = (0 until 1000).map { mergeableValueOf(it) }
    val mergedA = values.shuffled().reduce { a, b -> a.merge(b) }
    val mergedB = values.shuffled().reduce { a, b -> a.merge(b) }
    assertEquals(mergedA, mergedB)
}
```
And this one also passes!