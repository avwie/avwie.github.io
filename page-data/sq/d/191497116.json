{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"Compositional Patterns in Kotlin Part 2 - Components","slug":"/compositional-patterns-in-kotlin-part-2-components","date":"60-Mar 2021","hero":{"childImageSharp":{"fixed":{"src":"/static/76cc1293686d25adf49eb6632616779f/44274/hero.jpg"}}}},"excerpt":"This is the second part of the post on compositional patterns in Kotlin.\n","timeToRead":1}},{"node":{"frontmatter":{"title":"Compositional Patterns in Kotlin Part 1 - Delegation","slug":"/compositional-patterns-in-kotlin-part-1-delegation","date":"58-Feb 2021","hero":{"childImageSharp":{"fixed":{"src":"/static/7dffa55b1ddac18d357cfc19ee3991ad/44274/hero.jpg"}}}},"excerpt":"Roughly speaking there are two ways to obtain polymorphic behavior in OOP languages, 'classical' inheritance and composition. There are clear benefits in either approach depending on the domain one is trying to model. So this postâ€¦\n","timeToRead":11}}]}}}