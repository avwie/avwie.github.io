{"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"Compositional Patterns in Kotlin Part 2 - Component Model","slug":"/compositional-patterns-in-kotlin-part-2-component-model","date":"06-Mar 2021"},"excerpt":"This is the second part of the post on compositional patterns in Kotlin and will focus on a dynamic, or runtime, composition. There are a few ways to obtain dynamic composition, all with their own advantages and drawbacks.\n\n …\n","timeToRead":9}},{"node":{"frontmatter":{"title":"Compositional Patterns in Kotlin Part 1 - Delegation","slug":"/compositional-patterns-in-kotlin-part-1-delegation","date":"27-Feb 2021"},"excerpt":"Roughly speaking there are two ways to obtain polymorphic behavior in OOP languages, 'classical' inheritance and composition. There are clear benefits in either approach depending on the domain one is trying to model. So this post…\n","timeToRead":11}}]}}}